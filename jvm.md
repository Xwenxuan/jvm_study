# jvm

![image-20210806165207796](https://raw.githubusercontent.com/Xwenxuan/jvm_study/main/img/image-20210806165207796.png)

class 文件 == 字节码文件

一次编译：源文件->字节码文件

二次编译：字节码文件->机器指令

JVM是基于栈的架构方式，可移植性好

## JVM生命周期

 * 虚拟机的启动

   > 通过类引导加载器创建一个**初始类**来完成，这个类由虚拟机的具体实现指定

 * 虚拟机的执行

   > 一个运行的Java虚拟机有一个清晰的任务，就是**执行Java程序**
   >
   > 程序执行它才运行，程序结束他就结束
   >
   > *执行Java程序的时候，其实就是在执行一个Java虚拟机的进程*

* 虚拟机的退出
  1. 程序正常结束
  2. 程序在执行过程中遇到异常或错误
  3. 操作系统错误
  4. System.exit 方法 runtime.halt方法

## 类加载器

![image-20210928111724745](https://raw.githubusercontent.com/Xwenxuan/jvm_study/main/img/image-20210928111724745.png)

加载 -> 链接 -> 初始化

**加载的类信息存在于一块称为方法区的内存空间。方法区还会存在运行时常量池信息，可能还有字符串字面量和数字常量**



**支持两种类加载器**

* 引导类加载器（*非java实现的*）
  * C/C++实现，嵌套在JVM内部
  * 主要加载**核心类库**（java、javax、sun），用于提供JVM自身所需要的类
  * 加载扩展类和系统类加载器，指定他们的父类加载器
* 自定义类加载器（继承ClassLoader的类加载器都划分为自定义类加载器），包括扩展类加载器、系统类加载器和用户自定义类加载器
  * 扩展类加载器加载ext目录下的文件
  * 系统类（应用类）加载器一般就加载用户自定义类

**对于用户自定义类来说：默认使用系统类加载器进行加载**



### 加载

1. 通过一个类的全限定名获取定义此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转化为方法区运行时存储结构
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口

### 链接

1. 验证
   * 目的在于确保class字节流中符合虚拟机要求
   * 格式验证、元数据验证、字节码验证、符号引用验证
2. 准备
   * 为类变量分配内存并且设置该类变量的默认初始值--0值
   * 不包含用final修饰的static，因为final在编译时就会分配，准备阶段就会显示初始化
   * 不会为实例变量分配初始化，类变量分配在方法区中，而实例变量会随着对象一起分配到Java堆中
3. 解析
   * 将常量池中符号引用转化为直接引用
   * 会在JVM执行完初始化之后再执行
   * 符号引用就是一组符号来表示目标，直接引用就是指向目标的指针了（相当于对象和对象指针）

### 初始化

1. 初始化阶段就是执行类构造方法<clinit>()的过程，*只组合静态内容*（不等同于构造函数），我们常用的构造函数是<init>()方法
2. 这个方法不需要定义，编译器自己组合的，其中的指令按照源文件中出现顺序
3. 虚拟机保证一个类的<clinit>()方法在多线程下被同步加锁



### 双亲委派机制

1. 如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；
2. 如果父类加载器还存在其父类加载器，则继续向上委托，依次递归，请求最终到达最顶层的启动类加载器
3. 如果父类加载器可以完成类加载任务，则成功返回，倘若父类加载器无法王城此加载任务，子类加载器才会尝试自己去加载，这就是**双亲委派方式**

### 其他

在JVM中表示两个class对象是否为同一类存在两个必要条件

1. 类的完整类名必须一致，包括包名
2. 加载这个类的ClassLoader（实例）必须相同



## 运行时数据区 对应Runtime类（只有一个）

![image-20210928111738220](https://raw.githubusercontent.com/Xwenxuan/jvm_study/main/img/image-20210928111738220.png)

![image-20210928111748655](https://raw.githubusercontent.com/Xwenxuan/jvm_study/main/img/image-20210928111748655.png)

![image-20210928111816105](https://raw.githubusercontent.com/Xwenxuan/jvm_study/main/img/image-20210928111816105.png)

线程共享：方法区、堆

线程独有：PC、本地方法栈、虚拟机栈



### 线程

每个线程都与操作系统的线程一一对应

JVM中的线程：

	1. 虚拟机线程：在JVM达到安全点后出现
	2. 周期任务线程：周期事件的体现（比如终端）
	3. GC线程：垃圾回收用
	4. 编译线程：将字节码编译成本地代码
	5. 信号调度线程：接收信号并发送给JVM，在内部调用适当方法进行处理



### 程序计数器

**就是物理层面PC寄存器的模拟，指向下一条要执行指令的地址**

**一块很小的内存空间，存储当前方法的JVM指令地址，当时如果是native方法，则是未指定值**

**唯一一块没有OOM的区域**



### 虚拟机栈

主管Java程序的运行，它保存方法的局部变量（8种基本数据类型、**对象的引用地址，对象实际还是在堆中**）、部分结果，并参与方法的调用何返回，保存**栈桢**，一个栈桢保存一个方法。

* 栈大小可以设置动态也可以设置静态
  * 如果设置静态，超出会报StackOverflow
  * 如果动态，申请不到会报OOM

* -Xss 设置栈大小

* 栈桢的内部结构

  ![image-20210928111826128](https://raw.githubusercontent.com/Xwenxuan/jvm_study/main/img/image-20210928111826128.png)

  * 局部变量表

    * **最基本的单位是Slot（变量槽）**

    * 定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量

    * 建立在线程栈上，不存在数据安全问题

    * 局部变量表大小是在编译期间确定的

    * 32位类型占一个slog，64位占2个slot 按照声明顺序来存放 *非静态方法还有个this变量放到index为0的slot中*

    * slot可以重复利用，出作用域后就不需要了

    * 在栈桢中，**局部变量表中的变量也是重要的垃圾回收根节点，在局部变量表中被引用的对象不会被回收**

      > 索引    类型    参数
      >
      > 0         int      int k
      >
      > 1        long	long m
      >
      > 3		float 	float p

  * 操作数栈（用数组实现的）

    

    ![image-20210928111835006](https://raw.githubusercontent.com/Xwenxuan/jvm_study/main/img/image-20210928111835006.png)

    

    * 入栈、出栈字节码指令的操作数
    * 如果有返回值的话，其返回值将会被压入当前栈桢的操作数栈中
    * 栈顶缓存技术： 由于零地址指令更多读些次数，所以把栈顶元素全部缓存在物理cpu的寄存器中，降低对内存的读些次数

  * 动态链接（指向运行时常量池的方法引用）

    * 每一个栈桢内部都包含一下指向*运行时常量池*中该栈桢所属方法的引用，这个引用的目的就是能够实现动态链接

    * 字节码文件中，所有变量和方法应用都为符号引用，保存在class文件的常量池里，**一个方法调用另外的其他方法时，就是通过常量池指向方法的符号引用来表示的，动态链接就是将这些符号引用转化为调用方法的直接引用**

    * **常量池的作用，就是为了提供一些符号和常量，便于指令的识别**

      > #1 = Methodref #9.#10 //<init>
      >
      > #2 = Fieldref #8.#24 //num
      >
      > #10 utf8 num
      >
      > #11 = utf8 I

    * 其实多态也是invokevirtue来实现的，和c++虚函数类似

    * 方法的调用

      * invokestatic：调用静态方法，解析阶段确定为宜方法版本
      * invokespecial：调用<init>方法、私有及父类方法，解析阶段确定为法方法版本
      * Invokevirtual：调用所有虚方法（调用final也是，但不是实现多态了）
      * Invoke interface：调用接口方法
      * invokedynamic指令：为了实现动态类型（对类型检查放在运行期），静态类型语言就是放在编译期间检查
      * **方法区也有虚函数表！！！**

  * 方法返回地址

    * 存放调用该方法的pc寄存器的值
    * ireturn、lreturn、dreturn.... 引用类型返回areturn, void-> return
    * 本质上，方法的退出就是当前栈桢出栈的过程，需要恢复上层方法的运行环境（其实就是保存工作环境），**将返回值压入调用者栈桢的操作数栈、设置PC寄存器，让调用者继续执行下去**
    * **就是一个方法调用另一个方法的时候，这时候要保存该方法的下一条要执行的指令保存起来，再去执行调用的方法，执行完之后，继续执行该方法的指令，指令就保存在方法返回地址上**

  * 一些附加信息

### 本地方法接口

* 本地方法，就是使用Java调用非Java代码的接喽，本地方法不是Java实现的
* 主要是与Java外的环境交互，并且提升效率

### 本地方法栈

* 管理本地方法的调用

* 线程私有，允许是线程固定或者是可扩展大小
* **当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限**
  * 本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区
  * 它可以直接使用本地处理器中的寄存器
  * 直接从本地内存中分配内存
* 有的虚拟机可能没有本地方法栈



### 堆内存 

* 一些命令
  * -Xms 初始大小
  * -XMx 最大大小
  * -XX:newRatio：设置新生代与老年代的比例，默认是2
  * -XX:Survivoratio：设置新生代中Eden与survivor区的比例（默认是8）
  * -XX:-UseAdaptiveSizePolicy：关闭自适应的内存分配策略
  * -Xmn:设置新生代空间大小（一般不设置）
  * -XX:MaxTenuringThreshold= <N> 设置多少次GC放入老年代

一个进程-> 一个JVM实例 -> 一个运行时数据区

![image-20210928111850239](https://raw.githubusercontent.com/Xwenxuan/jvm_study/main/img/image-20210928111850239.png)

* 基本概念
  * 在JVM启动时就创建，大小也确定了，是JVM最大的一块内存
  * 堆内存大小是可以调节的
  * 物理上可以是不连续的空间，逻辑上是连续的
  * 堆是线程共享的，但是还有线程私有的部分（TLAB，thread local ）
  * 所有的类对象都在堆上分配内存（**但是还是有可能分配在栈上**）
  * 栈中保存的是对象的引用，指向堆中的对象
  * 在方法结束后（也就是引用消失）堆中的对象不会马上被移除，仅在垃圾收集的时候才会被移除
  * 堆是垃圾回收的重点区域
  
* 内存细分
  
  ![image-20210928111903776](https://raw.githubusercontent.com/Xwenxuan/jvm_study/main/img/image-20210928111903776.png)
  
  * Java 7 及以前分为：新生区+养老区+永久区
  * Java 8及之后则是：新生区+养老区+元空间（元空间其实是方法区了）
  * 新生代也可以划分为**Eden、Survivor0和Survivor1空间** 新生代和老年代的比例默认值为1:2，Eden:Survivor0:Survovor1 默认 8:1:1，使用自适应配置后才是8:1:1
    * Eden：对象最先创建的地方

* 存储在JVM中的Java对象可以被划分为两类：
  * 一类是在生命周期较短的瞬时对象，这类对象创建和消亡都非常迅速
  * 另一类生命周期却非常长，在某些极端情况下还能够与JVM的生命周期保持一致
* 对象分配过程   每个对象有个年龄计数器，每一次gc都会+1
  * YGC/Minor GC  **只有Eden满了之后才会触发**
    * Eden区满了之后所出发的垃圾回收
    * 这时还没被回收的旧翻到S0中
    * **第一次只判断Eden区，而后面几次则是对Eden+某个S区进行判读，放到另一个S区中**
    * **超过15次GC还没销毁的就放到老年代了**
    * 会引发STW，暂停其他用户线程，垃圾回收完之后，用户线程才会恢复运行
  * 特殊的分配情况
    * **Eden区放不下超大对象，直接放old区**
    * **如果老年代也放不下了，FullGC，majorGC**
    * **FullGC，majorGc后还放不下 直接OOM**
    * **YGC后S区放不下，直接放到老年代去**
  * Major GC 
    * 老年代回收
  * Full GC
    * 对整个堆进行垃圾回收
* 内存分配策略
  * 优先分配到Eden
  * 大对象直接分配到老年代，尽量避免程序中出现过多的大对象
  * 长期存活的对象分配到老年代
  * 如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代
  * TLAB
    * 堆区市线程共享区域，线程不安全
    * 为了避免多线程不安全，需要枷锁，影响分配速度
    * **在Eden区每个线程再划分线程私有的区域，每个线程独一份**
    * **空间比较小，只有Eden区的百分之1**
* 堆外存储技术
  * 分配在栈上，不需要gc
* 逃逸分析
  * 当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸
  * 当一个对象在方法被定义后，它被外部方法所引用，则认为发生逃逸，例如作为调用参数传递到其他方法中。
  * 如何快速判断是否发生逃逸分析：看对象在方法外是否被调用
  * **同步省略，如果一个对象别发现只能从一个线程被访问到，那这个对象的操作可以不考虑同步的问题，在动态编译的时候，发现不会有别的线程访问，就锁消除**



### 方法区（元空间）

![image-20210928111914276](https://raw.githubusercontent.com/Xwenxuan/jvm_study/main/img/image-20210928111914276.png)

* 逻辑上属于堆的一部分，但一些简单的实现不回去选择垃圾回收或进行压缩
* 方法区的大小决定了系统可以保存多少个类，如果定义了太多的类，导致方法区溢出，会OOM

#### 方法区内部结构

![image-20210928111923911](https://raw.githubusercontent.com/Xwenxuan/jvm_study/main/img/image-20210928111923911.png)



![image-20210928111932413](https://raw.githubusercontent.com/Xwenxuan/jvm_study/main/img/image-20210928111932413.png)



* 类型信息
  * 这个类型的完整有效名称（全名=包名.类名)
  * 这个类型直接父类的完整有效名（interface和Object类没有父类）
  * 这个类型的修饰符（public，abstract，final的某个子集）
  * 这个类型直接接口的一个有序列表
* 域信息
  * JVM必须再在方法区中保存类型的所有域的相关信息以及域的声明顺序
  * 域的相关信息包括：域名称、域类型、域修饰符（public，private，protected，static，finnal，volatile的某个子集）
* 方法信息
  * 方法名称
  * 方法返回类型
  * 方法参数的数量和类型
  * 方法的修饰符
  * 方法的字节码、操作数栈、局部变量表及大小（abstract和native除外）
  * 异常表（abstract和native方法除外）
    * 每个异常处理的开始位置、结束为止、代码处理在程序计数器中的偏移地址、被捕获异常类的常量池索引
* **运行时常量池**（包含常量池）
  * 常量池表（数量值、字符串值、类引用、字段引用、方法引用）
    * 字面量信息 就是硬编码内容
    * 各种符号引用。  就是不是真正的内容 只是一个代表，比如 某个方法名叫func，那就有个叫func的引用，但不是真正的方法，只是个名称，防止冗余
    * 常量池就相当于一些原料，是该类各种所需的物品的集合
  * 运行时常量池：常量池表中的符号引用就会变成真实的地址了
* Java8之后，**无永久代，类型信息、字段、方法、常量保存在本地内存的原空间，但字符串常量池、静态变量仍在堆中（指的是引用）**
* 元空间是使用本地内存的
* 方法区的垃圾回收
  * 常量池中废弃的常量
    * 只要常量池中的常量没有被任何地方引用，就可以回收
  * 不再使用的类型（费力不讨好）
    * 该类所有实例都已经被回收，该类的子类也不存在
    * 加载该类的类加载器已经被回收
    * 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方反射该类的方法

#### 创建对象的六个步骤

1. 判断对象类型是否加载、链接、初始化

2. 为对象分配内存
   1. 如果内存规整--指针碰撞（其实就是把指针移到当前对象存放的地址上）
   2. 如果内存不完整
      1. 虚拟机需要维护一个列表
      2. 空闲列表分配
   3. 处理并发安全问题
      1. 采用CAS失败重试、区域枷锁保证 更新的原子性
      2. 每个线程预先分配TLAB
   4. 初始化分配到的空间
      1. 所有属性设置默认值，保证对象实例在不赋值时可以直接使用
   5. 设置对象的对象头（元信息，hashcode那些东西）
   6. 执行init方法进行初始化（就是调用构造函数了）

#### 对象内存布局

1. 对象头
   1. 运行时元数据
      * 哈希值
      * GC分代年龄
      * 锁转台标识
      * 线程持有的锁。。。
   2. 类型指针
      * 指向类元数据的对应类型
2. 实例数据
   * 各种类型的字段
3. 对齐填充 就是内存对齐

#### 对象访问方式

1. 句柄访问

   ![image-20210928111942091](https://raw.githubusercontent.com/Xwenxuan/jvm_study/main/img/image-20210928111942091.png)

2. 直接指针

   ![image-20210928111946269](https://raw.githubusercontent.com/Xwenxuan/jvm_study/main/img/image-20210928111946269.png)



### StringTable

* **字符串常量池是不会存储相同的字符串的**
  * 字符串常量池底层是一个固定大小的HashTable
* 直接用字面量的方式声明的对象会直接存储在常量池中，new出来在堆中
* 如果不是则用intern方法，放到常量池中去
* 字符串拼接
  * 常量与常量的拼接结果在常量池，原理是编译期优化
  * 常量池中不回存在相同内容的常量
  * 只要其中有一个是变量，结果就在堆中（而不是常量池中），相当于new了。变量拼接的原理是StringBuilder
  * 如果拼接的结果调用intern()方法，则主动将常量池中还没有的字符串放入池中，并返回对象地址
* StringTable垃圾回收
* G1会对堆中重复的字符串进行去重



### 垃圾回收

#### 垃圾回收相关算法

* 标记阶段（对象存活判断）

  * 引用计数算法（Java没有使用）

    * 为每个对象保存一个整型的引用计数属性，记录引用情况
    * 实现简单，效率高
    * 但是需要单独的存储计数器，增加存储空间开销，**最重要的是无法处理循环引用的情况**

  * 可达性分析算法

    ![image-20210928143035266](https://raw.githubusercontent.com/Xwenxuan/jvm_study/main/img/image-20210928143035266.png)

    * GC Roots
      * **采用栈的方式存放变量和指针，所以一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root**
      * 虚拟机中的引用对象 各个线程被调用使用的方法中使用到的参数、局部变量等
      * 本地方法栈中引用的对象
      * 方法区中静态属性引用的对象
      * 方法区中常量引用的对象
      * 所有被同步所持有的对象
      * Java虚拟机内部的引用
    * 以根对象集合为起始点，按照从上至下的方式搜索被根对象所连接的目标对象是否可达
    * 内存中存活的对象都会被根对象集合直接或间接连接着，搜索走过的路径称为引用链
    * 如果目标对象没有任何引用链相连，则是不可达的，意味着该对象已经死亡，可以标记为垃圾对象

* 对象的finalization机制（析构函数），垃圾回收之前

  * finalize()方法（**千万不要主动的去调用**）
  * 对象的三种状态
    * 可触及的：从根节点开始，可以到达这个对象
    * 可复活的：对象的所有引用都被释放，但是对象可能在finalize()中复活
    * 不可触及的：对象的finalize()被调用，并且没有复活，那么就会进入补课触及状态，不可触及状态的对象不可能被复活，因为finalize()函数只会调用一次
  * 判断一个对象是否可回收的具体过程 **会有两次标记**
    * 如果没有引用链，则进行一次标记
    * 进行筛选，判断此对象是否有必要执行finalize方法
      * 如果该对象没有重写finalize方法，或者finalize方法已经被虚拟机调用过，则被判为不可触及的
      * 如果重写的finalize方法，且还未执行，那么就会插入执行队列中
      * 如果在执行finalize方法中又与一个引用链上的对象建立了联系，那么第二次标记就会移出要执行回收的队列，这是finalize方法就不会再调用，下一次再死亡就直接“ 不可触及状态了”。

* 清除阶段

  * 标记-清除算法

    * 标记：标记**可达的对象**
    * 清除：从头到尾线性便利，发现没有被标记可达，就回收
      * 这里清除不是真的置为空，把需要清除的对象地址保存在空闲的地址列表里，下次有新对象需要加载时，判断垃圾的位置空间是否够，够就放
    * 优缺点
      * 效率不高
      * GC需要停止所有其他工作
      * 会有内存碎片，空闲列表需要维护

  * 复制算法

    ![image-20210928152301399](https://raw.githubusercontent.com/Xwenxuan/jvm_study/main/img/image-20210928152301399.png)

    * 把存活对象氛围两块，每次只使用一块，要进行回收的时候，把一块中的所有存活对象复制到另一块区域，然后删除改区域的所有内容，完成垃圾回收
    * 优缺点
      * 实现简单，运行高效
      * 不会出现碎片问题
      * 缺点就是两倍的内存空间，使用G1需要维护引用关系

  * 标记-压缩算法（主要用在老年代，就是整理下内存）

    ![image-20210928154006012](https://raw.githubusercontent.com/Xwenxuan/jvm_study/main/img/image-20210928154006012.png)

    * 标记：这里和标记-清除算法一样
    * 压缩：将所有的存活对象有索要内存的另一端，俺顺序排放，之后，清理边界外所有的空间

* 增量收集算法

  * 现有的GC会引起STW，所有的应用线程都会挂起，增量收集算法可以解决这个问题
  * **通过对线程间冲突的妥善处理，允许垃圾回收线程以分阶段的方式来进行，也就是GC线程和应用线程交替执行**
  * 会造成垃圾回收成本的总体上升，系统吞吐量的下降

* 分区算法

  ![image-20210928155642483](https://raw.githubusercontent.com/Xwenxuan/jvm_study/main/img/image-20210928155642483.png)

  * 把堆空间划分许多小空间，每个小空间独立回收

* System.gc()或者Runtime.getRuntime().gc()的调用，会显示触发**Full GC**，同时对新生代和老年代进行回收，**但是无法确保对垃圾回收器的调用**



### 内存泄漏举例

* 只有对象不会再被程序用到了，但是GC又回收不了他们，才叫内存泄漏
* 宽泛意义上的内存泄漏指的是生命周期变得很长



### 安全点和安全区域

* 在特定位置开始GC，这个点就叫做**安全点**
* **安全区域**指的是在一段代码中，对象的引用关系不会发生变化，在这个区域内任何位置开始GC都是安全的



### Java中不同的引用

* 强引用

  > 就是正常的引用

* 软引用

  > 即将发生内存溢出时，会把这些回收

* 弱引用

  > 只能生存到垃圾回收之前

* 虚引用

  > 感觉没什么用的样子，都不能创建实例，唯一目的就是在这个对象回收时收到一个系统通知，跟踪垃圾回收过程

